(in-package :synth)
(use-package :cl)
(defparameter *volume-scale* nil)
(defparameter *sample-rate* 44100)
(defparameter *sample-format* nil)
(defparameter *isfile* nil)
(defun get-volume-scale(format)
  (cond
    ((equal format "S16_LE") 32757)
    ((equal format "S32_LE") 2147473647))
  )
(defmacro with-sound
    ((stream &rest options &key (sample-rate 44100) (format "S16_LE") (channels 2))
     &body body)
  `(let* ((aplay-process (sb-ext:run-program "/usr/bin/aplay"
                                    (list "-r" (princ-to-string ,sample-rate) "-f" (princ-to-string ,format) "-c" (princ-to-string ,channels) "-")
                                    :input :stream :output nil :wait nil )))
     (setf *volume-scale* (get-volume-scale ,format))
     (setf *sample-rate* ,sample-rate)
     (setf *sample-format* ,format)
     (setf *isfile* nil);This needs to be set to nil for write-sample to work correctly
     (unwind-protect
          (with-open-stream
              (,stream (sb-ext:process-input aplay-process))
            ,@body)
       (when aplay-process (sb-ext:process-close aplay-process)))))
(defmacro with-sound-file((stream name &key (sample-rate 44100) (format "S16_LE") (channels 2) (if-exists :supercede)) &body body)
  `(with-open-file (,stream ,name :direction :output :element-type '(signed-byte 16) :if-exists :supercede )
     (setf *isfile* t)
     (setf *volume-scale* (get-volume-scale ,format))
     (setf *sample-rate* ,sample-rate)
     (setf *sample-format* ,format)
     ,@body))
(defmacro <-(a b)
  "Assign one value to another and return the new one"
  `(progn
     (setf ,a ,b)
     ,a))
(defun get-byte(integer n)
  (ldb (byte 8 (* n 8)) integer))
(defun b-sin(n scale)
  (truncate (* scale (sin n))))
(defun sin-sound(freq volume offset)
  (declare (type single-float freq volume))
  (lambda (x)
    (declare (type fixnum x))
    (* (sin (* freq 2 pi (/ (- x offset) *sample-rate*))) volume)))
(defstruct (decay)
  (limit 1.0e-5 :type single-float)
  (start 0 :type fixnum)
  (end 0 :type fixnum))
(defstruct (linear-decay (:include decay)
                         (:conc-name ldecay-))
  "A linear decay mode, modelled after a slope moving downwards (or upwards if you're insane)"
  (rate 0.4 :type single-float))
(defstruct (exp-decay (:include decay)
                      (:conc-name ddecay-))
  "A damped decay mode, modelled after the amplitude of damped harmonic motion, also works upwards"
  (d-const 0.9 :type single-float))
(defstruct (bimodal-decay (:include decay)
                          (:conc-name bdecay-))
  "A bimodal decay mode, that is, that it is modelled after two different decays, which switch at a given point in time after the start"
  (a nil :type decay)
  (b nil :type decay)
  (switch 0 :type fixnum))
(defgeneric decay-multiplier(decay time))
(defmethod decay-multiplier((decay linear-decay) (time fixnum))
  (- 1.0
     (*
      (ldecay-rate decay)
      (/ (- time (decay-start decay))
         *sample-rate*))))
(defmethod decay-multiplier((decay exp-decay) (time fixnum))
  (exp (- (* (ddecay-d-const decay)
             (/ (- time (decay-start decay)) *sample-rate*)))))
(defmethod decay-multiplier((decay bimodal-decay)
                            (time fixnum))
  (if (< (+ (bdecay-switch decay) (decay-start decay))
         time)
      (decay-multiplier (bdecay-a decay) time)
      (decay-multiplier (bdecay-b decay) time)))
(defgeneric calc-decay(amplitude time decay))
(defmethod calc-decay(amplitude (time fixnum) (decay linear-decay))
  (* (decay-multiplier decay time) amplitude))
(defmethod calc-decay((amplitude single-float) (time fixnum) (decay exp-decay))
  (* amplitude (decay-multiplier decay time)))
(defun is-decay-alive(decay time)
  "Returns true if the decay's value is greater than its cutoff point"
  (< time (decay-end decay)))
(defun is-decay-active(decay time)
  (and (<= (decay-start decay) time)
       (>= (decay-end decay) time)))
(defun seconds(n)
  "Obtains the number of samples for n seconds"
  (declare (type number n))
  (truncate (* *sample-rate* n)))
(defun write-sample(value stream)
;  (declare (type single-float value))
     (if *isfile*
         (progn
           (print "writing-byte")
           (write-byte (truncate (* *volume-scale* value)) stream))
         (progn
           (write-byte (get-byte
                        (truncate (* *volume-scale* value)) 0)
                       stream)
           (write-byte (get-byte
                        (truncate (* *volume-scale* value))
                        1)
                       stream))))
(defstruct (instrument (:conc-name instr-))
  "An instrument, with decay types, voice generator, and time management"
  (voice #'sin-sound :type (function (t t t) (values number)));Really the voice-generator for the instrument
  (generators '()))
(defstruct (generator (:conc-name gen-))
  (voice nil)
  (decay nil :type decay))
(defun add-generator(instrument frequency amplitude start end &key (rate 0.4))
  (declare (type instrument instrument)
           (type number frequency amplitude)
           (type fixnum start end))
  (setf (instr-generators instrument)
         (append (list (make-generator :voice (funcall (instr-voice instrument) frequency amplitude start)
                                       :decay (make-linear-decay :start start :end end :rate rate)))
                 (instr-generators instrument))))
(defun clean-generators(instrument time)
  (delete-if-not (lambda (x)
                   (is-decay-alive (gen-decay x) time))
                 (instr-generators instrument)));Delete dead decays
(defun eval-generator(generator time)
  (if (generator-activep generator time)
      (calc-decay (funcall (gen-voice generator) time) time (gen-decay generator))
      0.0))
(defun generator-activep(generator time)
  (is-decay-active (gen-decay generator) time))
(defun tick(instrument time)
;  (clean-generators instrument time)
  (reduce #'+ (loop for i in (instr-generators instrument)
                collect (eval-generator i time))))
(defstruct (scale)
  (base-frequency 440.0 :type single-float);A4
  (exp-base 1.0594631 :type single-float));2^(1/12)
(defun scale-note(scale n)
  "Get the nth note of the given scale"
  (* (scale-base-frequency scale) (expt (scale-exp-base scale) n)))
